"""
Script for statistically evaluating various aspects of tsinfer performance.
"""
import argparse
import sys

import numpy as np
import pandas as pd
import matplotlib as mp
# Force matplotlib to not use any Xwindows backend.
mp.use('Agg')
import matplotlib.pyplot as plt
import seaborn as sns

import dendropy

import tsinfer
import tsinfer.cli as cli
import msprime

def make_errors(v, p):
    """
    For each sample an error occurs with probability p. Errors are generated by
    sampling values from the stationary distribution, that is, if we have an
    allele frequency of f, a 1 is emitted with probability f and a
    0 with probability 1 - f. Thus, there is a possibility that an 'error'
    will in fact result in the same value.
    """
    w = np.copy(v)
    if p > 0:
        m = v.shape[0]
        frequency = np.sum(v) / m
        # Randomly choose samples with probability p
        samples = np.where(np.random.random(m) < p)[0]
        # Generate observations from the stationary distribution.
        errors = (np.random.random(samples.shape[0]) < frequency).astype(int)
        w[samples] = errors
    return w


def generate_samples(ts, error_p):
    """
    Returns samples with a bits flipped with a specified probability.

    Rejects any variants that result in a fixed column.
    """
    G = np.zeros((ts.num_sites, ts.num_samples), dtype=np.int8)
    for variant in ts.variants():
        done = False
        # Reject any columns that have no 1s or no zeros
        while not done:
            G[variant.index] = make_errors(variant.genotypes, error_p)
            s = np.sum(G[variant.index])
            done = 0 < s < ts.sample_size
    return G


def infer_from_simulation(
        ts, recombination_rate=1, input_error=0, sample_error=0, method="C",
        path_compression=True):
    if input_error == 0:
        genotypes = ts.genotype_matrix()
    else:
        genotypes = generate_samples(ts, input_error)
    positions = [mut.position for mut in ts.mutations()]
    return tsinfer.infer(
        genotypes, positions=positions, sequence_length=ts.sequence_length,
        recombination_rate=recombination_rate, sample_error=sample_error,
        method=method, path_compression=path_compression)


def get_mean_rf_distance(ts1, ts2):
    """
    Returns the mean distance between the trees in the specified tree sequences.
    """
    assert ts1.sample_size == ts2.sample_size
    assert ts1.sequence_length == ts2.sequence_length
    trees1 = []
    intervals1 = []
    trees2 = []
    intervals2 = []
    tns = dendropy.TaxonNamespace()
    for t in ts1.trees():
        dt = dendropy.Tree.get(data=t.newick(), schema="newick", taxon_namespace=tns)
        trees1.append(dt)
        intervals1.append(t.interval)
    assert len(trees1) == ts1.num_trees
    for t in ts2.trees():
        dt = dendropy.Tree.get(data=t.newick(), schema="newick", taxon_namespace=tns)
        trees2.append(dt)
        intervals2.append(t.interval)
    assert len(trees2) == ts2.num_trees
    j1 = 0
    j2 = 0
    total_distance = 0
    total_metric = 0
    # I haven't tested this algorithm thoroughly, so there might be corner cases
    # not handled correctly. However, the total_distance assert below should
    # catch the problem if it occurs.
    while j1 < len(trees1) and j2 < len(trees2):
        # Each iteration of this loop considers one overlapping interval and
        # increments the counters.
        l1, r1 = intervals1[j1]
        l2, r2 = intervals2[j2]
        l = max(l1, l2)
        r = min(r1, r2)
        rf_distance = dendropy.calculate.treecompare.symmetric_difference(
                trees1[j1], trees2[j2])
        total_metric += rf_distance * (r - l)
        total_distance += r - l
        if r1 <= r2:
            j1 += 1
        if r1 >= r2:
            j2 += 1
    # assert total_distance, ts1.sequence_length)
    return total_metric / total_distance


def check_basic_performance():
    # Basic check to ensure that we get the same results regardless of the recombination
    # rate

    num_samples = 10
    MB = 10**6
    sites = []
    trees = []
    edges = []
    nodes = []
    rf_distance = []
    recombination_rate = []
    for seed in range(1, 10):
        ts_source = msprime.simulate(
            num_samples, length=1*MB, Ne=10**4, recombination_rate=1e-8, mutation_rate=1e-8,
            random_seed=seed)
        print("sim: n = ",
                ts_source.num_samples, ", m =", ts_source.num_sites,
                "num_trees = ", ts_source.num_trees)
        for exponent in range(0, 6):
            infer_recomb_rate = 10**(-exponent)
            ts_inferred = infer_from_simulation(
                ts_source, recombination_rate=infer_recomb_rate, sample_error=0)
            recombination_rate.append(infer_recomb_rate)
            rf = get_mean_rf_distance(ts_source, ts_inferred)
            rf_distance.append(get_mean_rf_distance(ts_source, ts_inferred))
            sites.append(ts_source.num_sites)
            trees.append(ts_inferred.num_trees / ts_source.num_trees)
            nodes.append(ts_inferred.num_nodes / ts_source.num_nodes)
            edges.append(ts_inferred.num_edges / ts_source.num_edges)

            # print("recombination_rate = ", recombination_rate)
            # print("mean rf = ", rf)
            # print("num_trees = ", ts_inferred.num_trees / ts_source.num_trees)
            # print("num_edges= ", ts_inferred.num_edges/ ts_source.num_edges)
    df = pd.DataFrame(data={
        "num_samples": num_samples,
        "recombination_rate": recombination_rate,
        "sites": sites,
        "trees": trees,
        "edges": edges,
        "nodes": nodes,
        "rf_distance": rf_distance})
    for y_value in ["trees", "nodes", "edges", "rf_distance"]:
        plt.figure()
        plot = sns.boxplot(x=df["recombination_rate"], y=df[y_value])
        plt.savefig("tmp__NOBACKUP__/{}.png".format(y_value))


def check_effect_error_param(input_error=0.0):
    num_samples = 10
    MB = 10**6
    sites = []
    trees = []
    edges = []
    nodes = []
    rf_distance = []
    error = []
    for seed in range(1, 10):
        ts_source = msprime.simulate(
            num_samples, length=1*MB, Ne=10**4, recombination_rate=1e-8, mutation_rate=1e-8,
            random_seed=seed)
        print("sim: n = ",
                ts_source.num_samples, ", m =", ts_source.num_sites,
                "num_trees = ", ts_source.num_trees)
        for err in [0] + list(10.0**-np.arange(1, 5)):
            ts_inferred = infer_from_simulation(
                ts_source, recombination_rate=1, input_error=input_error, sample_error=err)
            error.append(err)
            rf = get_mean_rf_distance(ts_source, ts_inferred)
            rf_distance.append(get_mean_rf_distance(ts_source, ts_inferred))
            sites.append(ts_source.num_sites)
            trees.append(ts_inferred.num_trees / ts_source.num_trees)
            nodes.append(ts_inferred.num_nodes / ts_source.num_nodes)
            edges.append(ts_inferred.num_edges / ts_source.num_edges)
        df = pd.DataFrame(data={
            "num_samples": num_samples,
            "error": error,
            "sites": sites,
            "trees": trees,
            "edges": edges,
            "nodes": nodes,
            "rf_distance": rf_distance})
        df.to_csv("tmp__NOBACKUP__/error_{}.csv".format(input_error))
        # df = pd.read_csv("tmp__NOBACKUP__/error_{}.csv".format(input_error))
        plt.figure()
        fig, axs = plt.subplots(nrows=2, ncols=2)
        for j, y_value in enumerate(["trees", "nodes", "edges", "rf_distance"]):
            sns.boxplot(x=df["error"], y=df[y_value], ax=axs[j // 2, j % 2])
        plt.suptitle("input_error = {}".format(input_error))
        plt.savefig("tmp__NOBACKUP__/error_{}.png".format(input_error))
        plt.clf()


def check_variable_recomb():
    rate = 1e-10
    Mb = 10**6
    num_samples = 20
    seed = 10
    recomb_map = msprime.RecombinationMap(
        positions=[0, 1*Mb, 1.1 * Mb, 2 * Mb],
        rates = [rate, 100 * rate, rate, 0], num_loci=10000)
    sites = []
    trees = []
    edges = []
    nodes = []
    rf_distance = []
    flat_rate = []
    for seed in range(1, 100):
        ts_source = msprime.simulate(
            num_samples, recombination_map=recomb_map, Ne=10**4, mutation_rate=1e-8,
            random_seed=seed,)
        print(
            "sim: n = ", ts_source.num_samples, ", m =", ts_source.num_sites,
            "num_trees = ", ts_source.num_trees)
        samples = np.zeros((ts_source.num_samples, ts_source.num_sites), dtype=np.int8)
        for variant in ts_source.variants():
            samples[:, variant.index] = variant.genotypes
        positions = np.array([site.position for site in ts_source.sites()])
        genetic_positions = np.array([
            recomb_map.physical_to_genetic(x) for x in positions])
        recombination_rate = np.zeros(ts_source.num_sites)
        recombination_rate[1:] = genetic_positions[1:] - genetic_positions[:-1]
        recombination_rate /= recomb_map.get_num_loci()

        for recomb_rate in [1, recombination_rate]:
            ts_inferred = tsinfer.infer(
                samples=samples, positions=positions,
                sequence_length=ts_source.sequence_length,
                recombination_rate=recomb_rate, sample_error=0)
            rf = get_mean_rf_distance(ts_source, ts_inferred)
            rf_distance.append(get_mean_rf_distance(ts_source, ts_inferred))
            flat_rate.append(recomb_rate is 1)
            sites.append(ts_source.num_sites)
            trees.append(ts_inferred.num_trees / ts_source.num_trees)
            nodes.append(ts_inferred.num_nodes / ts_source.num_nodes)
            edges.append(ts_inferred.num_edges / ts_source.num_edges)
        df = pd.DataFrame(data={
            "num_samples": num_samples,
            "sites": sites,
            "trees": trees,
            "edges": edges,
            "nodes": nodes,
            "rf_distance": rf_distance,
            "flat_rate": flat_rate})
            # df.to_csv("tmp__NOBACKUP__/error_{}.csv".format(input_error))
    plt.figure()
    fig, axs = plt.subplots(nrows=2, ncols=2)
    for j, y_value in enumerate(["trees", "nodes", "edges", "rf_distance"]):
        sns.boxplot(x=df["flat_rate"], y=df[y_value], ax=axs[j // 2, j % 2])
    plt.suptitle("variable recomb")
    plt.savefig("tmp__NOBACKUP__/variable_recomb.png")
    plt.clf()

    # print(ts_source.num_sites)
    # print(ts_source.num_trees)
    # for t in ts_source.trees():
    #     print(t.interval[1] - t.interval[0])


# TODO these are really unit tests. Move them into the tests directory.
def check_single_tree_one_mutation_per_branch():
    for num_samples in [4]:
        num_samples = 10
        for seed in range(1, 10):
            ts_source = msprime.simulate(num_samples, length=2 * num_samples, random_seed=seed)
            # Put a mutation on every branch.
            t = ts_source.dump_tables()
            for u in range(ts_source.num_nodes - 1):
                t.sites.add_row(position=u, ancestral_state="0")
                t.mutations.add_row(site=u, node=u, derived_state="1")
            ts_source = msprime.load_tables(**t.asdict())
            ts_inferred = infer_from_simulation(ts_source)
            assert ts_inferred.num_trees == 1


def verify_trees_equal(ts_source, ts_inferred):
    """
    Verifies that the inferred trees are topologically equal to the specified
    inferred trees.
    """
    for t in ts_source.trees():
        print(t.interval)
        print(t.draw(format="unicode"))
    print("++")
    for t in ts_inferred.trees():
        print(t.interval)
        print(t.draw(format="unicode"))

    print("==")


# TODO these are really unit tests. Move them into the tests directory.
def check_many_trees_one_mutation_per_branch():
    # for num_samples in [10, 100, 1000, 10000]:

    import daiquiri
    daiquiri.setup(level="DEBUG", outputs=(daiquiri.output.Stream(sys.stdout),))
    num_samples = 4
    print("num_samples = ", num_samples)
    # for seed in range(1, 1000):
    for seed in [19]:
        print(seed)
        recombination_map = msprime.RecombinationMap.uniform_map(
                100, 0.002, num_loci=100)
        ts_source = msprime.simulate(
                num_samples, recombination_map=recombination_map,
                random_seed=seed, model="smc_prime")
        # Put a mutation on every branch.
        tables = ts_source.dump_tables()
        j = 0
        for tree in ts_source.trees():
            left, right = tree.interval
            n = len(list(tree.nodes()))
            delta = (right - left) / n
            x = left
            for u in tree.nodes():
                if u != tree.root:
                    tables.sites.add_row(position=x, ancestral_state="0")
                    tables.mutations.add_row(site=j, node=u, derived_state="1")
                    j += 1
                    x += delta
        print(tables)
        ts_source = msprime.load_tables(**tables.asdict())
        print("samples")
        print(ts_source.genotype_matrix().T)
        ts_inferred = infer_from_simulation(ts_source,
                path_compression=False,
                # method="Py-matrix")
                method="P")
        print("num_trees", ts_source.num_trees, ts_inferred.num_trees)
        print("num_edges", ts_source.num_edges, ts_inferred.num_edges)
        verify_trees_equal(ts_source, ts_inferred)
        print(ts_inferred.tables)
        assert ts_source.num_trees >= ts_inferred.num_trees
        assert ts_source.num_edges >= ts_inferred.num_edges


# TODO these are really unit tests. Move them into the tests directory.
def check_single_tree_one_mutation_per_branch():
    for num_samples in [10, 100]:
        print("num_samples = ", num_samples)
        for seed in range(1, 10):
            ts_source = msprime.simulate(num_samples, length=2 * num_samples, random_seed=seed)
            # Put a mutation on every branch.
            t = ts_source.dump_tables()
            for u in range(ts_source.num_nodes - 1):
                t.sites.add_row(position=u, ancestral_state="0")
                t.mutations.add_row(site=u, node=u, derived_state="1")
            ts_source = msprime.load_tables(**t.asdict())
            ts_inferred = infer_from_simulation(ts_source)
            assert ts_inferred.num_trees == 1

def check_single_tree_two_mutations_per_branch():
    for num_samples in [10, 100]:
        print("num_samples = ", num_samples)
        num_mutations = 2 * num_samples * 2
        d = 1 / num_mutations
        for seed in range(1, 10):
            ts_source = msprime.simulate(num_samples, length=num_mutations, random_seed=seed)
            # Put a mutation on every branch.
            t = ts_source.dump_tables()
            j = 0
            for u in range(ts_source.num_nodes - 1):
                for _ in range(2):
                    t.sites.add_row(position=j * d, ancestral_state="0")
                    t.mutations.add_row(site=j, node=u, derived_state="1")
                    j += 1
            ts_source = msprime.load_tables(**t.asdict())
            ts_inferred = infer_from_simulation(ts_source)
            assert ts_inferred.num_trees == 1

def check_single_tree_many_mutations_per_branch():
    num_samples = 10
    for k in range(2, 20):
        print("k = ", k)
        num_mutations = 2 * num_samples * k
        d = 1 / num_mutations
        for seed in range(1, 10):
            ts_source = msprime.simulate(num_samples, length=num_mutations, random_seed=seed)
            # Put a mutation on every branch.
            t = ts_source.dump_tables()
            j = 0
            for u in range(ts_source.num_nodes - 1):
                for _ in range(k):
                    t.sites.add_row(position=j * d, ancestral_state="0")
                    t.mutations.add_row(site=j, node=u, derived_state="1")
                    j += 1
            ts_source = msprime.load_tables(**t.asdict())
            # print(ts_source.tables)
            ts_inferred = infer_from_simulation(ts_source)
            assert ts_inferred.num_trees == 1


def check_single_tree_high_mutation_rate():
    # import daiquiri
    # daiquiri.setup(level="DEBUG")
    # TODO change this test so that we throw a Poisson number of mutations on
    # each branch. It's very hard to have mutations on _every_ branch for larger
    # tree sizes.
    for num_samples in [3, 10, 50]:
        for seed in range(1, 10):
            ts_source = msprime.simulate(num_samples, random_seed=seed, mutation_rate=5000)
            print("sim = ", num_samples, ts_source.num_sites, seed)
            nodes = set()
            for site in ts_source.sites():
                for mutation in site.mutations:
                    nodes.add(mutation.node)
            # if nodes != set(range(ts_source.num_nodes - 1)):
            #     continue
            assert nodes == set(range(ts_source.num_nodes - 1))
            ts_inferred = infer_from_simulation(ts_source)
            # for t in ts_source.trees():
            #     print(t.draw(format="unicode"))
            # print(ts_inferred.num_trees)
            # for t in ts_inferred.trees():
            #     print(t.draw(format="unicode"))
            assert ts_inferred.num_trees == 1


##############################
# Updated code to work with the CLI
##############################



def multiple_recombinations(ts):
    """
    Returns true if the specified tree sequence contains multiple recombinations.
    """
    for _, e_out, _ in ts.edge_diffs():
        if len(e_out) > 4:
            return True
    return False

def run_perfect_inference(args):
    for seed in range(1, args.num_replicates + 1):
        base_ts = msprime.simulate(
            args.sample_size, Ne=10**4, length=args.length * 10**6,
            recombination_rate=1e-8, random_seed=seed, model="smc_prime")
        print("simulated ts with n={} and {} trees; seed={}".format(
            base_ts.num_samples, base_ts.num_trees, seed))
        if multiple_recombinations(base_ts):
            print("Multiple recombinations; skipping")
            continue
        ts, inferred_ts = tsinfer.run_perfect_inference(
            base_ts, num_threads=args.num_threads, progress=args.progress,
            extended_checks=args.extended_checks,
            time_chunking=not args.no_time_chunking)
        print("n={} num_trees={} num_sites={}".format(
            ts.num_samples, ts.num_trees, ts.num_sites))
        assert ts.tables.edges == inferred_ts.tables.edges
        assert ts.tables.sites == inferred_ts.tables.sites
        assert ts.tables.mutations == inferred_ts.tables.mutations
        assert np.array_equal(ts.tables.nodes.flags, inferred_ts.tables.nodes.flags)
        assert np.any(ts.tables.nodes.time != inferred_ts.tables.nodes.time)


def setup_logging(args):
    log_level = "WARN"
    if args.verbosity > 0:
        log_level = "INFO"
    if args.verbosity > 1:
        log_level = "DEBUG"
    if args.log_section is None:
        daiquiri.setup(level=log_level)
    else:
        daiquiri.setup(level="WARN")
        logger = logging.getLogger(args.log_section)
        logger.setLevel(log_level)


if __name__ == "__main__":

    top_parser = argparse.ArgumentParser(
        description="Simple inferface for running various tsinfer evaluations.")
    top_parser.add_argument(
        "-V", "--version", action='version',
        version='%(prog)s {}'.format(tsinfer.__version__))

    subparsers = top_parser.add_subparsers(dest="subcommand")
    subparsers.required = True

    parser = subparsers.add_parser(
        "perfect-inference", aliases=["pi"],
        help="Runs the perfect inference process on simulated tree sequences.")
    parser.set_defaults(runner=run_perfect_inference)
    parser.add_argument("--sample-size", "-n", type=int, default=10)
    parser.add_argument(
        "--length", "-l", type=float, default=1, help="Sequence length in MB")
    parser.add_argument("--num-replicates", "-r", type=int, default=1)
    parser.add_argument("--num-threads", "-t", type=int, default=0)
    parser.add_argument(
        "--progress", "-p", action="store_true",
        help="Show a progress monitor.")
    parser.add_argument(
        "--extended-checks", "-X", action="store_true",
        help="Enable extra consistency checking (slow)")
    parser.add_argument(
        "--no-time-chunking", action="store_true",
        help="Disable time-chunking to give each ancestor a distinct time.")
    cli.add_logging_arguments(parser)

    args = top_parser.parse_args()
    cli.setup_logging(args)
    args.runner(args)


    # check_basic_performance()
    # check_effect_error_param(float(sys.argv[1]))
    # plot_basic_performance()
    # check_variable_recomb()
    # check_single_tree_one_mutation_per_branch()
    # check_single_tree_two_mutations_per_branch()
    # check_single_tree_many_mutations_per_branch()
    # check_single_tree_high_mutation_rate()
    # check_many_trees_one_mutation_per_branch()


