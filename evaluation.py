"""
Script for statistically evaluating various aspects of tsinfer performance.
"""

import sys

import numpy as np
import pandas as pd
import matplotlib as mp
# Force matplotlib to not use any Xwindows backend.
mp.use('Agg')
import matplotlib.pyplot as plt
import seaborn as sns

import dendropy

import tsinfer
import msprime

def make_errors(v, p):
    """
    For each sample an error occurs with probability p. Errors are generated by
    sampling values from the stationary distribution, that is, if we have an
    allele frequency of f, a 1 is emitted with probability f and a
    0 with probability 1 - f. Thus, there is a possibility that an 'error'
    will in fact result in the same value.
    """
    w = np.copy(v)
    if p > 0:
        m = v.shape[0]
        frequency = np.sum(v) / m
        # Randomly choose samples with probability p
        samples = np.where(np.random.random(m) < p)[0]
        # Generate observations from the stationary distribution.
        errors = (np.random.random(samples.shape[0]) < frequency).astype(int)
        w[samples] = errors
    return w


def generate_samples(ts, error_p):
    """
    Returns samples with a bits flipped with a specified probability.

    Rejects any variants that result in a fixed column.
    """
    print("generating errors at ", error_p)
    S = np.zeros((ts.sample_size, ts.num_mutations), dtype=np.int8)
    for variant in ts.variants():
        done = False
        # Reject any columns that have no 1s or no zeros
        while not done:
            S[:, variant.index] = make_errors(variant.genotypes, error_p)
            s = np.sum(S[:, variant.index])
            done = 0 < s < ts.sample_size
    return S


def infer_from_simulation(ts, recombination_rate, input_error=0, sample_error=0):
    if input_error == 0:
        samples = np.zeros((ts.num_samples, ts.num_sites), dtype=np.int8)
        for variant in ts.variants():
            samples[:, variant.index] = variant.genotypes
    else:
        samples = generate_samples(ts, input_error)
    positions = [mut.position for mut in ts.mutations()]
    return tsinfer.infer(
        samples=samples, positions=positions, sequence_length=ts.sequence_length,
        recombination_rate=recombination_rate, sample_error=sample_error)


def get_mean_rf_distance(ts1, ts2):
    """
    Returns the mean distance between the trees in the specified tree sequences.
    """
    assert ts1.sample_size == ts2.sample_size
    assert ts1.sequence_length == ts2.sequence_length
    trees1 = []
    intervals1 = []
    trees2 = []
    intervals2 = []
    tns = dendropy.TaxonNamespace()
    for t in ts1.trees():
        dt = dendropy.Tree.get(data=t.newick(), schema="newick", taxon_namespace=tns)
        trees1.append(dt)
        intervals1.append(t.interval)
    assert len(trees1) == ts1.num_trees
    for t in ts2.trees():
        dt = dendropy.Tree.get(data=t.newick(), schema="newick", taxon_namespace=tns)
        trees2.append(dt)
        intervals2.append(t.interval)
    assert len(trees2) == ts2.num_trees
    j1 = 0
    j2 = 0
    total_distance = 0
    total_metric = 0
    # I haven't tested this algorithm thoroughly, so there might be corner cases
    # not handled correctly. However, the total_distance assert below should
    # catch the problem if it occurs.
    while j1 < len(trees1) and j2 < len(trees2):
        # Each iteration of this loop considers one overlapping interval and
        # increments the counters.
        l1, r1 = intervals1[j1]
        l2, r2 = intervals2[j2]
        l = max(l1, l2)
        r = min(r1, r2)
        rf_distance = dendropy.calculate.treecompare.symmetric_difference(
                trees1[j1], trees2[j2])
        total_metric += rf_distance * (r - l)
        total_distance += r - l
        if r1 <= r2:
            j1 += 1
        if r1 >= r2:
            j2 += 1
    # assert total_distance, ts1.sequence_length)
    return total_metric / total_distance


def check_basic_performance():
    # Basic check to ensure that we get the same results regardless of the recombination
    # rate

    num_samples = 10
    MB = 10**6
    sites = []
    trees = []
    edges = []
    nodes = []
    rf_distance = []
    recombination_rate = []
    for seed in range(1, 10):
        ts_source = msprime.simulate(
            num_samples, length=1*MB, Ne=10**4, recombination_rate=1e-8, mutation_rate=1e-8,
            random_seed=seed)
        print("sim: n = ",
                ts_source.num_samples, ", m =", ts_source.num_sites,
                "num_trees = ", ts_source.num_trees)
        for exponent in range(0, 6):
            infer_recomb_rate = 10**(-exponent)
            ts_inferred = infer_from_simulation(
                ts_source, recombination_rate=infer_recomb_rate, sample_error=0)
            recombination_rate.append(infer_recomb_rate)
            rf = get_mean_rf_distance(ts_source, ts_inferred)
            rf_distance.append(get_mean_rf_distance(ts_source, ts_inferred))
            sites.append(ts_source.num_sites)
            trees.append(ts_inferred.num_trees / ts_source.num_trees)
            nodes.append(ts_inferred.num_nodes / ts_source.num_nodes)
            edges.append(ts_inferred.num_edges / ts_source.num_edges)

            # print("recombination_rate = ", recombination_rate)
            # print("mean rf = ", rf)
            # print("num_trees = ", ts_inferred.num_trees / ts_source.num_trees)
            # print("num_edges= ", ts_inferred.num_edges/ ts_source.num_edges)
    df = pd.DataFrame(data={
        "num_samples": num_samples,
        "recombination_rate": recombination_rate,
        "sites": sites,
        "trees": trees,
        "edges": edges,
        "nodes": nodes,
        "rf_distance": rf_distance})
    for y_value in ["trees", "nodes", "edges", "rf_distance"]:
        plt.figure()
        plot = sns.boxplot(x=df["recombination_rate"], y=df[y_value])
        plt.savefig("tmp__NOBACKUP__/{}.png".format(y_value))


def check_effect_error_param(input_error=0.0):
    num_samples = 10
    MB = 10**6
    sites = []
    trees = []
    edges = []
    nodes = []
    rf_distance = []
    error = []
    for seed in range(1, 100):
        ts_source = msprime.simulate(
            num_samples, length=1*MB, Ne=10**4, recombination_rate=1e-8, mutation_rate=1e-8,
            random_seed=seed)
        print("sim: n = ",
                ts_source.num_samples, ", m =", ts_source.num_sites,
                "num_trees = ", ts_source.num_trees)
        for err in [0] + list(10.0**-np.arange(1, 5)):
            ts_inferred = infer_from_simulation(
                ts_source, recombination_rate=1, input_error=input_error, sample_error=err)
            error.append(err)
            rf = get_mean_rf_distance(ts_source, ts_inferred)
            rf_distance.append(get_mean_rf_distance(ts_source, ts_inferred))
            sites.append(ts_source.num_sites)
            trees.append(ts_inferred.num_trees / ts_source.num_trees)
            nodes.append(ts_inferred.num_nodes / ts_source.num_nodes)
            edges.append(ts_inferred.num_edges / ts_source.num_edges)
        df = pd.DataFrame(data={
            "num_samples": num_samples,
            "error": error,
            "sites": sites,
            "trees": trees,
            "edges": edges,
            "nodes": nodes,
            "rf_distance": rf_distance})
        df.to_csv("tmp__NOBACKUP__/error_{}.csv".format(input_error))
        # df = pd.read_csv("tmp__NOBACKUP__/error_{}.csv".format(input_error))
        plt.figure()
        fig, axs = plt.subplots(nrows=2, ncols=2)
        for j, y_value in enumerate(["trees", "nodes", "edges", "rf_distance"]):
            sns.boxplot(x=df["error"], y=df[y_value], ax=axs[j // 2, j % 2])
        plt.suptitle("input_error = {}".format(input_error))
        plt.savefig("tmp__NOBACKUP__/error_{}.png".format(input_error))
        plt.clf()

if __name__ == "__main__":
    # check_basic_performance()
    check_effect_error_param(float(sys.argv[1]))
    # plot_basic_performance()
